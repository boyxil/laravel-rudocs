# Представления (виды) и отклики сервера (Responses)

## Содержание

- [Основы](#the-basics)
- [Присоединение данных к представлению](#binding-data-to-views)
- [Связанные представления](#nesting-views)
- [Именные представления](#named-views)
- [Компоновщик представлений](#view-composers)
- [Перенаправления](#redirects)
- [Перенаправление со сбрасываемыми(одноразовыми) данными](#redirecting-with-flash-data)
- [Загрузки](#downloads)
- [Обработка ошибок](#errors)

<a name="the-basics"></a>
## Основы

Представления есть тот код HTML, который передается для показа пользователю вашим пприложением. При разделении представлений и бизнес-логики приложения, ваш код становится чистым и легким для понимания.

Все представления хранятся в папке **application/views** и имеют расширение PHP файлов. Класс **View** предлагает простые пути решения вопросов формирования ваших представлений и доставки их пользователю. смотрим примеры!

#### Создание представления:

	<html>
		I'm stored in views/home/index.php!
	</html>

#### Выдача представления из маршрута:

	Route::get('/', function()
	{
		return View::make('home.index');
	});

#### Выдача представления из контроллера:

	public function action_index()
	{
		return View::make('home.index');
	});

#### Проверка существования представления:

	$exists = View::exists('home.index');

Иногда вам нужно немного больше контроля над ответом, отправленым в браузер. Например, вам может понадобиться установить пользовательский заголовок ответа, или изменить код HTTP статуса. Поступаем так:

#### Выдача кастомизированного отклика:

	Route::get('/', function()
	{
		$headers = array('foo' => 'bar');

		return Response::make('Hello World!', 200, $headers);
	});

#### Выдача кастомизированного отклика, содержащегося в представлении:

	return Response::view('home', 200, $headers);

#### Выдача JSON отклика:

	return Response::json(array('name' => 'Batman'));

#### выдача Eloquent модели как JSON:

	return Response::eloquent(User::find(1));

<a name="binding-data-to-views"></a>
## Присоединение данных к представлению

Обычно, маршрут и контроллер запрашивают данные у модели, которые необходимы для передачи в представление для дальнейшего отображения пользователю. И нам нужен способ, как эо сделать. Вы можете выбрать по своему усмотрению любой из нескольких способов, предлагаемых Laravel!

#### Присоединение данных к представлению:

	Route::get('/', function()
	{
		return View::make('home')->with('name', 'James');
	});

#### Доступ к связанным данным в представлении:

	<html>
		Hello, <?php echo $name; ?>.
	</html>

#### Списочные вставки данных в представление:

	View::make('home')
		->with('name', 'James')
		->with('votes', 25);

#### Передача массивов с присоединением к представлению:

	View::make('home', array('name' => 'James'));

#### Использование магических (magic) методов для передачи данных:

	$view->name  = 'James';
	$view->email = 'example@example.com';

#### Использование интерфейса доступа к массивам для присоединения данных:

	$view['name']  = 'James';
	$view['email'] = 'example@example.com';

<a name="nesting-views"></a>
## Связанные представления

Часто необходимо создавать связанные(вложенные) представления. Их иногда еще называют "частичными". Такое решение помогает сохранять небольшой размер представлений и использовать модульность.

#### Присоединение вложенного представления с использованием "nest" метода:

	View::make('home')->nest('footer', 'partials.footer');

#### Передача данных во вложенное представление:

	$view = View::make('home');

	$view->nest('content', 'orders', array('orders' => $orders));

Иногда может понадобиться вложить непосредственно одно представление в другое. В этом вам поможет **render** хелпер:

#### Использование "render" хелпера для отображения представления:

	<div class="content">
		<?php echo render('user.profile'); ?>
	</div>
Кроме того, часто возникает необходимость использовать частичное представление данных, например, для отображения списков. Так, для отображения представления одного набора данных вы можете использовать частичное представление, чтобы потом соединить все представления для единообразного вида с помощью **render_each** хелпера:

#### Отображение частичного представления для каждого набора данных из массива::

	<div class="orders">
		<?php echo render_each('partials.order', $orders, 'order');
	</div>
Первый параметр - это частичный вид, второй - массив, третий - это имя переменной, которой передается очередной элемент массива для передачи в частичный вид.

<a name="named-views"></a>
## Именованные представления

Именованные представления делают ваш код выразительным и организованным. Использовать их очень просто:

#### Определение именованого представления:

	View::name('layouts.default', 'layout');

#### Получение самого представления по имени:

	return View::of('layout');

#### Присоединение данных к именованному представлению:

	return View::of('layout', array('orders' => $orders));

<a name="view-composers"></a>
## Компоновщик представления

Каждый раз, когда приложение создает представление, вызывается событие "composer". Вы можете использовать это событие для присоединения к представлению различных ресурсов, таких, как javascript, стили css, или каких-то общих данных. Например, привязать к представлению боковую панель для навигации по случайным статьям в блоге. Вам нужно привязать частичное представление к основному представлению. Затем определить компоновщик для этого представления. Компоновщик может запрашивать таблицу статей и передавать необходимые данные в представление. И никаких разбросанных по коду методов! Компоновщики обычно определяются в **application/routes.php**. Например:

#### Регистрация омпоновщика для представления "home":

	View::composer('home', function($view)
	{
		$view->nest('footer', 'partials.footer');
	});

Теперь при каждом создании представления "home", экземпляр представления будет передан в закрытую функцию Closure, где будут произведены необходимые вам действия.

#### Определение копоновщика для управления несколькими представлениями:

	View::composer(array('home', 'profile'), function($view)
	{
		//
	});

> **Примечание:** Представление может иметь несколько компоновщиков. Гуляй, не хочу!

<a name="redirects"></a>
## Перенаправления

Заметим, и это важно, что каждый маршрут и контроллер требуют, чтобы формируемый ими отклик производился при помощи инструкции 'return'. Обязательно вызывайте "Redirect::to()" там, где вам нужно переадресовать пользователя. Для этого используйте "return Redirect::to()". Это отличие от других фреймворков важно и не стоит упускать его из вида для избежания ошибок.

#### Перенаправление на другой URI:

	return Redirect::to('user/profile');

#### Перенаправление со специальным статусом:

	return Redirect::to('user/profile', 301);

#### Перенаправление на защищенный URI:

	return Redirect::to_secure('user/profile');

#### Переадресация в начало приложения:

	return Redirect::home();

#### Переадресация на вызвавшее действие:

	return Redirect::back();

#### Переадресация на именной маршрут:

	return Redirect::to_route('profile');

#### Переадресация на действие контроллера:

	return Redirect::to_action('home@index');
Иногда может понадобиться сделать переадресацию на именной маршрут, при этом изменить значния, передаваемые в маску маршрута. Это просто сделать путем замены маски маршрута на нужное значение:

#### Переадресация на именной маршрут со значением маски:

	return Redirect::to_route('profile', array($username));

#### Переадресация на действие контроллера со значением маски:

	return Redirect::to_action('user@profile', array($username));

<a name="redirecting-with-flash-data"></a>
## Переадресация со сбрасываемыми (одноразовыми) данными

После того, как пользователь создаст аккаунт или залогинится в вашем приложении, он, в общем случае, может получить приветственное сообщение или статус-сообщение. Но как определить сообщение, чтобы оно стало доступным для следующего запроса? Используйте with() метод для передачи одноразовых данных при переадресации.

	return Redirect::to('profile')->with('status', 'Welcome Back!');

Вы можете получить доступ  к вашему сообщению, применив get метод класса Session:

	$status = Session::get('status');

*Рекомендуется к прочтению:*

- *[Сессии](/docs/session/config)*

<a name="downloads"></a>
## Downloads

#### Sending a file download response:

	return Response::download('file/path.jpg');

#### Sending a file download and assigning a file name:

	return Response::download('file/path.jpg', 'photo.jpg');

<a name="errors"></a>
## Обработка ошибок
Для генерации соответствующих страниц ошибок определите тип ошибки, которая должна быть возвращена.
Соответствующая страница представления ошибки из папки **views/error** будет автоматически выдана.

#### Генерация ошибки 404:

	return Response::error('404');

#### Генерация ошибки 500:

	return Response::error('500');
