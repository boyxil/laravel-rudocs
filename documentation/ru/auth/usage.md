# Использование авторизации

## Содержание

- [Соль и Хэш](#hash)
- [Вход](#login)
- [Защита маршрутов](#filter)
- [Запросы к залогиненной User модели](#user)
- [Выход](#logout)
- [Создание пользовательского драйвера](#drivers)

> **Примечание:** Перед использованием класса Auth вы должны определить [определить драйвер сессии](/docs/session/config).

<a name="hash"></a>
## Соль и Хэш

При использовании класса **Auth** класса настоятельно рекомендуется хэшировать и "присаливать" (добавлять соль) все пароли. К веб-разработке нужно подходить ответственно. "Присоленые", захэшированные пароли сделают попытки взлома при помощи радужных таблиц просто нецелесообразными.

"Присоленые" и захэшированные пароли получаются при использовании класса **Hash**. Класс Hash использует алгоритм хэширования **bcrypt**. Пример:

	$password = Hash::make('secret');

Метод **make** класса Hash вернет хэш-строку из 60 символов.
Вы можете сравнить нехэшированное значение с хэшированным, используя метод **check** Hash класса:

	if (Hash::check('secret', $hashed_value))
	{
		return 'The password is valid!';
	}

<a name="login"></a>
## Вход
Вход пользователя в приложение прост посредством метода **attempt**  класса Auth. Просто вставьте имя и пароль в метод. Оба этих параметра должны находиться во входном массиве, что позволяет обеспечить максимальную гибкость драйвера, так как некоторые драйверы могут потребовать разное количество аргументов. Метод входа вернет **true** в случае подтверждения полномочий, или **false** в противном случае:

	$credentials = array('username' => 'example@gmail.com', 'password' => 'secret');

	if (Auth::attempt($credentials))
	{
	     return Redirect::to('user/profile');
	}

Если полномочия подтверждены, ID пользователя будет сохранено в сессии и ему будет присвоен статус "logged in" для последующих запросов к приложению.

Для определения того, что пользователь вошел и имеет статус "logged in", используется метод **check**:

	if (Auth::check())
	{
	     return "You're logged in!";
	}

Используйте метод **login** для входа пользователя без подтверждения полномочий, например, после входа пользователя, когда он первый раз зарегистрировался в приложении. Просто вставьте объект пользователя или его ID:

	Auth::login($user);

	Auth::login(15);

<a name="filter"></a>
## Защита маршрутов


Она является общей для ограничения доступа к определенным маршрутам только для зарегистрированных пользователей. В Laravel это достигается использованием [фильтров авторизации](/docs/routing#filters). Если пользователь залогинен, запрос проходит нормально, в противном случае, если пользователь не авторизован, он будет переадресован на страницу авторизации ("login") [именные маршруты](/docs/routing#named-routes).

Для защиты маршрута, просто добавьте фильтр **auth**:

	Route::get('admin', array('before' => 'auth', function() {}));

> **Примечание:**  Вы вольны запрограммировать фильтр **auth**  как вам будет угодно. Реализацию по умолчанию вы можете найти в **application/routes.php**.

<a name="user"></a>
## Запросы к залогиненной User модели

Пока пользователь залогинен в приложении, вы можете получить доступ к пользовательской модеои при помощи метода **user** класса Auth:

	return Auth::user()->email;

> **Примечание:**  Если пользователь не залогинен, метод **user** вернет NULL.

<a name="logout"></a>
## Выход

Готовы к выходу из приложения?

	Auth::logout();
Этот метод удалит ID пользователя из сессии, и пользователь уже не будет считаться авторизованным для последующих запросов к вашему приложению.
