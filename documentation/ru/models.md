# Модели и библиотеки

## Содержание

- [Модели](#models)
- [Библиотеки](#libraries)
- [Автозагрузка](#auto-loading)
- [Лучшие практики](#best-practices)

<a name="models"></a>
## Модели

Модель - это сердце вашего приложения.Логика вашего приложения (контроллеры / маршруты) и представления (html) являются всего лишь посредниками при взаимодействии пользователя и модели. Типичное использование логики с использованием моделей описаны в [Business Logic](http://en.wikipedia.org/wiki/Business_logic).

*Некоторые примеры функциональности, существующие в рамках моделей:*

- Операции с базами данных
- Файловый ввод-вывод
- Операции с веб сервисами

Например, вы пишите блог. Вы хотите иметь модель "Post". Пользователи захотят комментировать записи в блоге, таким образом, вам нужна модель "Comment". Раз пользователи будут оставлять комментарии, также необходима модель "User". Есть идеи?

<a name="libraries"></a>
## Библиотеки

Библиотеки классов выполняют задачи, не специфичне для вашего приложения. Например, преобразование PDF  в HTML. Эти задачи, несмотря на свою сложность, не являются специфичными для вашего приложения, поэтому их можно считать библиотеками.

Создание библитеки также просто, как и создание класса. Создайте класс и  сохранените его в директории библиотеки.
Creating a library is as easy as creating a class and storing it in the libraries folder. В следующем примере мы создадим простую библиотеку с методом, который отображает текст, который передается ему в виде параметра. In the following example, we will create a simple library with a method that echos the text that is passed to it. Создадим файл **printer.php** со следующим кодом и разместим его в **application/libraries**.

	<?php

	class Printer {

		public static function write($text) {
			echo $text;
		}
	}

Теперь вы можете вызвать Printer::write('this text is being echod from the write method!') из любого места вашего приложения.

<a name="auto-loading"></a>
## Автозагрузка

Библиотеки и модели очень просто используются в Laravel посредством автозагрузки. Для получения болле подробной информации обратитесь к разделу [Автозагрузка классов](/docs/loading).

<a name="best-practices"></a>
## Лучшие практики

Мы все слышали мантру: "Контроллер должен быть тонким!". Но, как мы можем применить это в реальной жизни? Вполне возможно, что частью проблемы является слово "модель". Что это еще такое? Этот термин полезен для применения? Многие ассоциируют модель с базой данных, что приводит к толстым, раздутым контроллерам, и тонким моделям, способных только обеспечивать доступ к базе данных. Давайте рассмотрим несколько альтернатив.

Что, если мы вообще уберем папку с моделями? После чего используем для нее более полезное название. На самом деле, двайте назовем ее также, как и наще приложение. Например, мы создаем сайт сопровождения спутника "Trackler", поэтому мы и создадим директорию "trackler" в папке нашего приложения. 

Прекрасно! Теперь давайте разделим наши классы на "entities", "services", и "repositories". Таким образом, мы создали соответствующую папку для каждого типа классов в папке "trackler". Рассмотрим каждую из них:

### Entities

Будем считать, что "entities" хранит данные нашего приложения. В основном это свойства. Итак, нам нужен класс Location со свойствами latitude и longitude, указывающими на положение спутника. Это может выглядеть так:

	<?php namespace Trackler\Entities;
	
	class Location {

		public $latitude;
		public $longitude;

		public function __construct($latitude, $longitude)
		{
			$this->latitude = $latitude;
			$this->longitude = $longitude;
		}

	}

Выглядит неплохо. Свойства мы организовали, теперь приступим к остальным двум папкам.

### Services

"Services" содержат процессы (*processes*) нашего приложения. Итак, продолжим наш пример "Trackler". наше приложение может иметь форму, посредством которой пользователь может ввести свое GPS-местоположение. В свою очередь, нам понадобится проверить правильность ввода координат и соответствие их принятому формату. Нам нужно валидировать (*validate*) *location entity* (см. выше). ДЛя этого просто создадим папку "validators" со следующим классом:

	<?php namespace Trackler\Services\Validators;

	use Trackler\Entities\Location;

	class Location_Validator {

		public static function validate(Location $location)
		{
			// Validate the location instance...
		}

	}

Отлично! Мы имеем отличное средство проверки (*валидации*) ввода, изолированного от контроллеров и маршрутов! Итак, мы валидировали ввод и готовы к хранению полученных данных. Что же делать теперь?

### Repositories

"Repositories" это слой доступа к данным вашего приложения. Они отвечают за хранение и извлечение "entities" вашего приложения. Давайте продолжим использовать наши *location* свойства (из "entities") в нашем примере. Нам нужно локальное хранилище (*repository*) для хранения наших данных. Мы можем использовать любой механизм для этого, от еляционных баз данных и до Redis, или любой другой способ хранения. Посмотрим на пример:

	<?php namespace Trackler\Repositories;

	use Trackler\Entities\Location;

	class Location_Repository {

		public function save(Location $location, $user_id)
		{
			// Store the location for the given user ID...
		}

	}

Теперь у нас есть четкое разделение между свойствами, сервисами и хранилищами. Это означает, что мы может внедрять заглушки в необходимые нам места приложения и тестировать их в изоляции от базы данных.Кроме того, мы можем спокойно, без ущерба для приложения менять способы хранения данных без влияния на конроллеры, сервисы, свойства. Мы добились хорошего *разделения задач*. 

*Рекомендуем прочитать:*

- [IoC Контейнер](/docs/ioc)
