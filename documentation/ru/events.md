# События

## Содержание

- [Основы](#the-basics)
- [Включение события](#firing-events)
- [отслеживание события](#listening-to-events)
- [Очередь событий](#queued-events)
- [События Laravel](#laravel-events)

<a name="the-basics"></a>
## основы

События обеспечивают хороший способ построения не связанных приложений, и позволяет встраивать плагины в ядро ​​приложения без изменения кода.

<a name="firing-events"></a>
## Включение события

Для включения события, просто сообщите классу **Event** имя события, которое нужно включить:

#### Включение события:

	$responses = Event::fire('loaded');

Заметьте, что мы присваиваем результат метода **fire** перменной. Этот метод возвращает массив, содержащий ответы от всех прослушиваемых событий.

Иногда требуется включить событие, но получить только первый ответ от него:

#### Включение события для получения только первого ответа:

	$response = Event::first('loaded');

> **Прримечание:** Метод **first** прослушивает все события, но возвращает только первый ответ.

Метод **Event::until** выполняет процедуру обработки события до тех пор, пока не придет первый ненулевой ответ.

#### Включение события до получения ненулевого ответа:

	$response = Event::until('loaded');

<a name="listening-to-events"></a>
## Прослушивание событий

Какая польза от использования событий, которые никто не слушает? Регистрация обработчика события:

#### Регистрация обработчика события:

	Event::listen('loaded', function()
	{
		// I'm executed on the "loaded" event!
	});

Анонимная функция обеспечивает исполнения кода при каждом возникновении события:

<a name="queued-events"></a>
## Очередь событий

Вы можете создать очередь событий, не исполняя их обработчики немедленно. Т.е. поставить собтия в очередь. Для этого существуют методы `queue`и `flush`. Сначала ставим событие в очередь с уникальным идентификатором:

#### Регистрация очереди событий:

	Event::queue('foo', $user->id, array($user));

Этот метод принимает три параметра. Первый определяет имя очереди, второй - уникальный идентификатор ключа в очереди, и третий - массив параметров для передачи обработчику очереди.

Далее, мы регистрируем обработчик для очереди `foo`:

#### Регистрация обработчика:

	Event::flusher('foo', function($key, $user)
	{
		//
	});

Обработчик принимает два аргумента. Первый, уникальный идентификатор обрабатываемой очереди. Второй (и другие, при необходимости) передает параметры для события в очереди.

Наконец, мы можем запустить обработчик очееди и обработать все события в очереди при помощи метода `flush`:

	Event::flush('foo');

<a name="laravel-events"></a>
## События Laravel

Здесь собраны события ядра Laravel:

#### Событие, отрабатываемое при старте бандла:

	Event::listen('laravel.started: bundle', function() {});

#### Событие, отрабатываемое при запросе к базе данных:

	Event::listen('laravel.query', function($sql, $bindings, $time) {});

#### Событие, отрабатываемое перед пердачей ответа в браузер:

	Event::listen('laravel.done', function($response) {});

#### Событие, отрабатываемое при логировании сообщения с использованием класса Log:

	Event::listen('laravel.log', function($type, $message) {});
