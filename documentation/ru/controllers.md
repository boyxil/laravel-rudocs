# Контроллеры

## Содержание

- [Основы](#the-basics)
- [Маршруты контроллеров](#controller-routing)
- [Контроллеры бандлов](#bundle-controllers)
- [Фильтры действий](#action-filters)
- [Связанные контроллеры](#nested-controllers)
- [Шаблоны контроллеров](#controller-layouts)
- [RESTful контроллеры](#restful-controllers)
- [Внедрение зависимостей](#dependency-injection)
- [Фабрика контроллеров](#controller-factory)

<a name="the-basics"></a>
## Основы

Контроллеры представляют собой классы, которые отвечают за принятие пользовательского ввода и управляют взаимодействием между моделями, библиотеками и представлениями(видами). Как правило, контроллеры запрашивают у модели данные, чтобы затем отправить полученный результат в представление для отображения пользователю.

Использование контроллеров является наиболее распространенным методом реализации логики приложения в современной веб-разработке.
Тем не менее, Laravel предоставляет возможность обработки логики приложения непосредственно через маршруты, минуя контроллеры.
Детально это рассматривается в разделе [Маршрутизация](/docs/routing). Новым пользователям, конечно же, лучше начинать с использования контроллеров. Не существует такого приложения, основанного на логике маршрутов, которое не может быть реализовано при помощи контроллеров.

Классы контроллеров хранятся в **application/controllers** и являются потомком класса Base\_Controller. Контроллер домашней страницы Home\_Controller также поставляется с Laravel.

#### Создание простого контроллера:

	class Admin_Controller extends Base_Controller
	{

		public function action_index()
		{
			//
		}

	}

**Actions** - это имена методов, которые доступны для запросов из веб. **Actions**-методы имеют префикс "action\_". Любые другие методы контроллера недоступны для запросов из веб.

> **Примечание:** Класс Base\_Controller наследует главный класс Laravel Controller, и предоставляет удобное место для размещения общих методов для разных классов контроллеров, которые будут унаследованы от него.

<a name="controller-routing"></a>
## Маршруты контроллеров

Важно помнить, что все маршруты в Laravel должны быть четко определены, в том числе маршруты в контроллерах.

Это означает, что методы контроллеров, которые не были определены маршрутами не будут доступны. В то же время можно автоматически определить все методы в контроллере, используя контроллер регистрации маршрута. Обычно регистрация маршрутов производится в **application/routes.php**.

Ознакомтесь с [разделом маршрутизации](/docs/routing#controller-routing) для более полного представления о маршрутах контроллеров.

<a name="bundle-controllers"></a>
## Контроллеры бандлов

В Laravel бандлами называют модульную систему пакетов. Бандлы легко могут быть настроены на обработку запросов вашего приложения. Подробнее об этом рассказано в разделе [Бандлы](/docs/bundles).

Создание контроллеров бандлов практически идентично созданию контроллеров приложения.
Имя контроллера нужно компоновать с именем бандла в виде префикса таким образом, что, для контроллера "admin", например, класс контроллера будет выглядеть как:

#### Создание класса контроллера бандла:

	class Admin_Home_Controller extends Base_Controller
	{

		public function action_index()
		{
			return "Hello Admin!";
		}

	}

Но, как же определить маршрут для контроллера бандла? Это просто. Просто укажите:

#### Определение маршрута для контроллера бандла:

	Route::controller('admin::home');

Отлично! Теперь у нас есть доступ для контроллера "home" бандла "admin"!

> **Примечание:** В Laravel синтаксис двойного двоеточия используется для доступа к бандлам. Больше информации вы найдете в [документации по бандлам](/docs/bundles).

<a name="action-filters"></a>
## Фильтры действий

Фильтры действий - это методы, которые выполняются до или после того, как будет вызван метод контроллера. В Laravel вы контролируете не только какой фильтр будет применен к контроллеру, но и контролировать, на какой из запросов HTTP (post, get, put, and delete) этот фильтр будет применен.

Вы можете определить "before" и "after" фильтр также для всех действий контроллера в конструкторе последнего.

#### Присоединение фильтра ко всем действиям контроллера:

	$this->filter('before', 'auth');

В этом примере фильтр 'auth' будет выполнен перед вызовом любого действия контроллера. Фильтр авторизации в Laravel доступен "из-коробки", вы можете его найти в **application/routes.php**. Фильтр авторизации проверяет авторизацию пользователя и, в случае необходимости, перенапрвляет его на страницу авторизации 'login'.

#### Присоединение фильтра только к некоторым действиям:

	$this->filter('before', 'auth')->only(array('index', 'list'));

В этом примере фильтр 'auth' будет выполнен только перед действиями action_index() или action_list(). Пользователи долны быть авторизованы при доступе к этим страницам. Напротив, другие действия контроллера не требуют авторизации.

#### Присоединение фильтра ко всем действиям за исключением некоторых:

	$this->filter('before', 'auth')->except(array('add', 'posts'));

Также, как и в предыдущем примере, эта инструкция предписывает применить фильтр только к некоторым действиям.  Но, вместо того, чтобы объявить действия, где применяется фильтр, мы указываем действия, где фильтр не применяется. Это иногда полезно с точки зрения безопасности, когда могут быть добавлены новые действия в контроллере, а разработчик "забыл", что они требуют авторизации. Таким образом, требование авторизации будет распространено на все действия контроллера, кроме тех, где авторизация не требуется.

#### Присоединение фильтра при запросе POST:

	$this->filter('before', 'csrf')->on('post');

Этот пример показывает, как определить фильтр только при POST запросе. В данном случае запускается фильтр 'csrf' только при получении POST запроса. Фильтр csrf разработан для защиты форм (например,от спам-роботов) и встроен в Laravel. Фильтр csrf вы можете найти в **application/routes.php**.

*Дополнительно:*

- *[Фильтры маршрутов](/docs/routing#filters)*

<a name="nested-controllers"></a>
## Связанные контроллеры

Контроллеры (классы контроллеров) могут быть свободно расположены в директории **application/controllers**, образуя любой уровень вложенности директорий.

Например, определим класс контроллера 'panel' и расположим его в **controllers/admin/panel.php**.

	class Admin_Panel_Controller extends Base_Controller
	{

		public function action_index()
		{
			//
		}

	}

#### Регистрация маршрута связанного контроллера с использованием "dot" синтаксиса (аналогично классам Java):

	Route::controller('admin.panel');

> **Примечание:** При применении связанных контроллеров, всегда регистрируйте их маршруты от наиболее вложенных к наименее вложенным, чтобы избежать маскирования маршрутов.

#### Пример доступа к связанному контроллеру:

	http://localhost/admin/panel

<a name="controller-layouts"></a>
## Шаблоны контроллеров

Полная документация по использованию шаблонов в контроллерах может быть найдена в разделе [Шаблоны](http://laravel.com/docs/views/templating).

<a name="restful-controllers"></a>
## RESTful контроллеры

Вместо префикса "action_", вы можете использовать в качестве перфикса тип HTTP метода (post, get, put, delete), такие действия тоже будут доступны.
> **Примечание:** При этом необходимо добавить свойство контроллера 'restful'.

#### Добавление свойства RESTful контроллеру:

	class Home_Controller extends Base_Controller
	{

		public $restful = true;

	}

#### Построение действий RESTful контроллера:

	class Home_Controller extends Base_Controller
	{

		public $restful = true;

		public function get_index()
		{
			//
		}

		public function post_index()
		{
			//
		}

	}

Это особенно бывает полезно, когда необходимо разделить логику операций, например в CRUD.

<a name="dependency-injection"></a>
## Внедрение зависимостей

Если вы особо привержены созданию тестируемого кода, возможно, вы захотите внедрить зависимости в конструктор вашего конроллера. Пожалуйста. Просто зарегистрируйте ваш контроллер в [IoC container](/docs/ioc). При регистрации контроллера в контейнере обязательно поставьте префикс **controller**. В общем, в **application/start.php** мы можем зарегистрировать контроллер как:

	IoC::register('controller: user', function()
	{
		return new User_Controller;
	});

Когда контроллер будет вызван вашим приложением, Laravel автоматически определит, зарегистрирован ли контроллер в контейнере, и, если да, он использует контейнер и создаст экземпляр контроллера.

> **Примечание:** Перед использованием внедрения зависимостей, пожалуйста, ознакомтесь с [IoC контейнер](/docs/ioc).

<a name="controller-factory"></a>
## Фабрика контроллера

Если вы хотите еще ​​большего контроля над экземплярами контроллеров, например, при использовании сторонних IoC контейнеров, вам необходимо будет использовать фабрику контроллеров.

**Регистрация события по управлению созданием контроллера:**

	Event::listen(Controller::factory, function($controller)
	{
		return new $controller;
	});
Событие принимает имя класса контроллера, который должен быть разрешен (создан). Всё, что вам нужно сделать — вернуть экземпляр класса контроллера.
